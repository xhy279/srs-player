{"version":3,"file":"index.esm.js","sources":["../src/srs.sdk.js","../src/index.tsx"],"sourcesContent":["\n//\n// Copyright (c) 2013-2021 Winlin\n//\n// SPDX-License-Identifier: MIT\n//\n\n'use strict';\n\nfunction SrsError(name, message) {\n    this.name = name;\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\nSrsError.prototype = Object.create(Error.prototype);\nSrsError.prototype.constructor = SrsError;\n\n// Depends on adapter-7.4.0.min.js from https://github.com/webrtc/adapter\n// Async-awat-prmise based SRS RTC Publisher.\nfunction SrsRtcPublisherAsync() {\n    var self = {};\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    self.constraints = {\n        audio: true,\n        video: {\n            width: {ideal: 320, max: 576}\n        }\n    };\n\n    // @see https://github.com/rtcdn/rtcdn-draft\n    // @url The WebRTC url to play with, for example:\n    //      webrtc://r.ossrs.net/live/livestream\n    // or specifies the API port:\n    //      webrtc://r.ossrs.net:11985/live/livestream\n    // or autostart the publish:\n    //      webrtc://r.ossrs.net/live/livestream?autostart=true\n    // or change the app from live to myapp:\n    //      webrtc://r.ossrs.net:11985/myapp/livestream\n    // or change the stream from livestream to mystream:\n    //      webrtc://r.ossrs.net:11985/live/mystream\n    // or set the api server to myapi.domain.com:\n    //      webrtc://myapi.domain.com/live/livestream\n    // or set the candidate(eip) of answer:\n    //      webrtc://r.ossrs.net/live/livestream?candidate=39.107.238.185\n    // or force to access https API:\n    //      webrtc://r.ossrs.net/live/livestream?schema=https\n    // or use plaintext, without SRTP:\n    //      webrtc://r.ossrs.net/live/livestream?encrypt=false\n    // or any other information, will pass-by in the query:\n    //      webrtc://r.ossrs.net/live/livestream?vhost=xxx\n    //      webrtc://r.ossrs.net/live/livestream?token=xxx\n    self.publish = async function (url) {\n        var conf = self.__internal.prepareUrl(url);\n        self.pc.addTransceiver(\"audio\", {direction: \"sendonly\"});\n        self.pc.addTransceiver(\"video\", {direction: \"sendonly\"});\n        //self.pc.addTransceiver(\"video\", {direction: \"sendonly\"});\n        //self.pc.addTransceiver(\"audio\", {direction: \"sendonly\"});\n\n        if (!navigator.mediaDevices && window.location.protocol === 'http:' && window.location.hostname !== 'localhost') {\n            throw new SrsError('HttpsRequiredError', `Please use HTTPS or localhost to publish, read https://github.com/ossrs/srs/issues/2762#issuecomment-983147576`);\n        }\n        var stream = await navigator.mediaDevices.getUserMedia(self.constraints);\n\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream#Migrating_to_addTrack\n        stream.getTracks().forEach(function (track) {\n            self.pc.addTrack(track);\n\n            // Notify about local track when stream is ok.\n            self.ontrack && self.ontrack({track: track});\n        });\n\n        var offer = await self.pc.createOffer();\n        await self.pc.setLocalDescription(offer);\n        var session = await new Promise(function (resolve, reject) {\n            // @see https://github.com/rtcdn/rtcdn-draft\n            var data = {\n                api: conf.apiUrl, tid: conf.tid, streamurl: conf.streamUrl,\n                clientip: null, sdp: offer.sdp\n            };\n            console.log(\"Generated offer: \", data);\n\n            const xhr = new XMLHttpRequest();\n            xhr.onload = function() {\n                if (xhr.readyState !== xhr.DONE) return;\n                if (xhr.status !== 200 && xhr.status !== 201) return reject(xhr);\n                const data = JSON.parse(xhr.responseText);\n                console.log(\"Got answer: \", data);\n                return data.code ? reject(xhr) : resolve(data);\n            }\n            xhr.open('POST', conf.apiUrl, true);\n            xhr.setRequestHeader('Content-type', 'application/json');\n            xhr.send(JSON.stringify(data));\n        });\n        await self.pc.setRemoteDescription(\n            new RTCSessionDescription({type: 'answer', sdp: session.sdp})\n        );\n        session.simulator = conf.schema + '//' + conf.urlObject.server + ':' + conf.port + '/rtc/v1/nack/';\n\n        return session;\n    };\n\n    // Close the publisher.\n    self.close = function () {\n        self.pc && self.pc.close();\n        self.pc = null;\n    };\n\n    // The callback when got local stream.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream#Migrating_to_addTrack\n    self.ontrack = function (event) {\n        // Add track to stream of SDK.\n        self.stream.addTrack(event.track);\n    };\n\n    // Internal APIs.\n    self.__internal = {\n        defaultPath: '/rtc/v1/publish/',\n        prepareUrl: function (webrtcUrl) {\n            var urlObject = self.__internal.parse(webrtcUrl);\n\n            // If user specifies the schema, use it as API schema.\n            var schema = urlObject.user_query.schema;\n            schema = schema ? schema + ':' : window.location.protocol;\n\n            var port = urlObject.port || 1985;\n            if (schema === 'https:') {\n                port = urlObject.port || 443;\n            }\n\n            // @see https://github.com/rtcdn/rtcdn-draft\n            var api = urlObject.user_query.play || self.__internal.defaultPath;\n            if (api.lastIndexOf('/') !== api.length - 1) {\n                api += '/';\n            }\n\n            var apiUrl = schema + '//' + urlObject.server + ':' + port + api;\n            for (var key in urlObject.user_query) {\n                if (key !== 'api' && key !== 'play') {\n                    apiUrl += '&' + key + '=' + urlObject.user_query[key];\n                }\n            }\n            // Replace /rtc/v1/play/&k=v to /rtc/v1/play/?k=v\n            apiUrl = apiUrl.replace(api + '&', api + '?');\n\n            var streamUrl = urlObject.url;\n\n            return {\n                apiUrl: apiUrl, streamUrl: streamUrl, schema: schema, urlObject: urlObject, port: port,\n                tid: Number(parseInt(new Date().getTime()*Math.random()*100)).toString(16).slice(0, 7)\n            };\n        },\n        parse: function (url) {\n            // @see: http://stackoverflow.com/questions/10469575/how-to-use-location-object-to-parse-url-without-redirecting-the-page-in-javascri\n            var a = document.createElement(\"a\");\n            a.href = url.replace(\"rtmp://\", \"http://\")\n                .replace(\"webrtc://\", \"http://\")\n                .replace(\"rtc://\", \"http://\");\n\n            var vhost = a.hostname;\n            var app = a.pathname.substring(1, a.pathname.lastIndexOf(\"/\"));\n            var stream = a.pathname.slice(a.pathname.lastIndexOf(\"/\") + 1);\n\n            // parse the vhost in the params of app, that srs supports.\n            app = app.replace(\"...vhost...\", \"?vhost=\");\n            if (app.indexOf(\"?\") >= 0) {\n                var params = app.slice(app.indexOf(\"?\"));\n                app = app.slice(0, app.indexOf(\"?\"));\n\n                if (params.indexOf(\"vhost=\") > 0) {\n                    vhost = params.slice(params.indexOf(\"vhost=\") + \"vhost=\".length);\n                    if (vhost.indexOf(\"&\") > 0) {\n                        vhost = vhost.slice(0, vhost.indexOf(\"&\"));\n                    }\n                }\n            }\n\n            // when vhost equals to server, and server is ip,\n            // the vhost is __defaultVhost__\n            if (a.hostname === vhost) {\n                var re = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/;\n                if (re.test(a.hostname)) {\n                    vhost = \"__defaultVhost__\";\n                }\n            }\n\n            // parse the schema\n            var schema = \"rtmp\";\n            if (url.indexOf(\"://\") > 0) {\n                schema = url.slice(0, url.indexOf(\"://\"));\n            }\n\n            var port = a.port;\n            if (!port) {\n                // Finger out by webrtc url, if contains http or https port, to overwrite default 1985.\n                if (schema === 'webrtc' && url.indexOf(`webrtc://${a.host}:`) === 0) {\n                    port = (url.indexOf(`webrtc://${a.host}:80`) === 0) ? 80 : 443;\n                }\n\n                // Guess by schema.\n                if (schema === 'http') {\n                    port = 80;\n                } else if (schema === 'https') {\n                    port = 443;\n                } else if (schema === 'rtmp') {\n                    port = 1935;\n                }\n            }\n\n            var ret = {\n                url: url,\n                schema: schema,\n                server: a.hostname, port: port,\n                vhost: vhost, app: app, stream: stream\n            };\n            self.__internal.fill_query(a.search, ret);\n\n            // For webrtc API, we use 443 if page is https, or schema specified it.\n            if (!ret.port) {\n                if (schema === 'webrtc' || schema === 'rtc') {\n                    if (ret.user_query.schema === 'https') {\n                        ret.port = 443;\n                    } else if (window.location.href.indexOf('https://') === 0) {\n                        ret.port = 443;\n                    } else {\n                        // For WebRTC, SRS use 1985 as default API port.\n                        ret.port = 1985;\n                    }\n                }\n            }\n\n            return ret;\n        },\n        fill_query: function (query_string, obj) {\n            // pure user query object.\n            obj.user_query = {};\n\n            if (query_string.length === 0) {\n                return;\n            }\n\n            // split again for angularjs.\n            if (query_string.indexOf(\"?\") >= 0) {\n                query_string = query_string.split(\"?\")[1];\n            }\n\n            var queries = query_string.split(\"&\");\n            for (var i = 0; i < queries.length; i++) {\n                var elem = queries[i];\n\n                var query = elem.split(\"=\");\n                obj[query[0]] = query[1];\n                obj.user_query[query[0]] = query[1];\n            }\n\n            // alias domain for vhost.\n            if (obj.domain) {\n                obj.vhost = obj.domain;\n            }\n        }\n    };\n\n    self.pc = new RTCPeerConnection(null);\n\n    // To keep api consistent between player and publisher.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream#Migrating_to_addTrack\n    // @see https://webrtc.org/getting-started/media-devices\n    self.stream = new MediaStream();\n\n    return self;\n}\n\n// Depends on adapter-7.4.0.min.js from https://github.com/webrtc/adapter\n// Async-await-promise based SRS RTC Player.\nfunction SrsRtcPlayerAsync() {\n    var self = {};\n\n    // @see https://github.com/rtcdn/rtcdn-draft\n    // @url The WebRTC url to play with, for example:\n    //      webrtc://r.ossrs.net/live/livestream\n    // or specifies the API port:\n    //      webrtc://r.ossrs.net:11985/live/livestream\n    //      webrtc://r.ossrs.net:80/live/livestream\n    // or autostart the play:\n    //      webrtc://r.ossrs.net/live/livestream?autostart=true\n    // or change the app from live to myapp:\n    //      webrtc://r.ossrs.net:11985/myapp/livestream\n    // or change the stream from livestream to mystream:\n    //      webrtc://r.ossrs.net:11985/live/mystream\n    // or set the api server to myapi.domain.com:\n    //      webrtc://myapi.domain.com/live/livestream\n    // or set the candidate(eip) of answer:\n    //      webrtc://r.ossrs.net/live/livestream?candidate=39.107.238.185\n    // or force to access https API:\n    //      webrtc://r.ossrs.net/live/livestream?schema=https\n    // or use plaintext, without SRTP:\n    //      webrtc://r.ossrs.net/live/livestream?encrypt=false\n    // or any other information, will pass-by in the query:\n    //      webrtc://r.ossrs.net/live/livestream?vhost=xxx\n    //      webrtc://r.ossrs.net/live/livestream?token=xxx\n    self.play = async function(url) {\n        var conf = self.__internal.prepareUrl(url);\n        self.pc.addTransceiver(\"audio\", {direction: \"recvonly\"});\n        self.pc.addTransceiver(\"video\", {direction: \"recvonly\"});\n        //self.pc.addTransceiver(\"video\", {direction: \"recvonly\"});\n        //self.pc.addTransceiver(\"audio\", {direction: \"recvonly\"});\n\n        var offer = await self.pc.createOffer();\n        await self.pc.setLocalDescription(offer);\n        var session = await new Promise(function(resolve, reject) {\n            // @see https://github.com/rtcdn/rtcdn-draft\n            var data = {\n                api: conf.apiUrl, tid: conf.tid, streamurl: conf.streamUrl,\n                clientip: null, sdp: offer.sdp\n            };\n            console.log(\"Generated offer: \", data);\n\n            const xhr = new XMLHttpRequest();\n            xhr.onload = function() {\n                if (xhr.readyState !== xhr.DONE) return;\n                if (xhr.status !== 200 && xhr.status !== 201) return reject(xhr);\n                const data = JSON.parse(xhr.responseText);\n                console.log(\"Got answer: \", data);\n                return data.code ? reject(xhr) : resolve(data);\n            }\n            xhr.open('POST', conf.apiUrl, true);\n            xhr.setRequestHeader('Content-type', 'application/json');\n            xhr.send(JSON.stringify(data));\n        });\n        await self.pc.setRemoteDescription(\n            new RTCSessionDescription({type: 'answer', sdp: session.sdp})\n        );\n        session.simulator = conf.schema + '//' + conf.urlObject.server + ':' + conf.port + '/rtc/v1/nack/';\n\n        return session;\n    };\n\n    // Close the player.\n    self.close = function() {\n        self.pc && self.pc.close();\n        self.pc = null;\n    };\n\n    // The callback when got remote track.\n    // Note that the onaddstream is deprecated, @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/onaddstream\n    self.ontrack = function (event) {\n        // https://webrtc.org/getting-started/remote-streams\n        self.stream.addTrack(event.track);\n    };\n\n    // Internal APIs.\n    self.__internal = {\n        defaultPath: '/rtc/v1/play/',\n        prepareUrl: function (webrtcUrl) {\n            var urlObject = self.__internal.parse(webrtcUrl);\n\n            // If user specifies the schema, use it as API schema.\n            var schema = urlObject.user_query.schema;\n            schema = schema ? schema + ':' : window.location.protocol;\n\n            var port = urlObject.port || 1985;\n            if (schema === 'https:') {\n                port = urlObject.port || 443;\n            }\n\n            // @see https://github.com/rtcdn/rtcdn-draft\n            var api = urlObject.user_query.play || self.__internal.defaultPath;\n            if (api.lastIndexOf('/') !== api.length - 1) {\n                api += '/';\n            }\n\n            var apiUrl = schema + '//' + urlObject.server + ':' + port + api;\n            for (var key in urlObject.user_query) {\n                if (key !== 'api' && key !== 'play') {\n                    apiUrl += '&' + key + '=' + urlObject.user_query[key];\n                }\n            }\n            // Replace /rtc/v1/play/&k=v to /rtc/v1/play/?k=v\n            apiUrl = apiUrl.replace(api + '&', api + '?');\n\n            var streamUrl = urlObject.url;\n\n            return {\n                apiUrl: apiUrl, streamUrl: streamUrl, schema: schema, urlObject: urlObject, port: port,\n                tid: Number(parseInt(new Date().getTime()*Math.random()*100)).toString(16).slice(0, 7)\n            };\n        },\n        parse: function (url) {\n            // @see: http://stackoverflow.com/questions/10469575/how-to-use-location-object-to-parse-url-without-redirecting-the-page-in-javascri\n            var a = document.createElement(\"a\");\n            a.href = url.replace(\"rtmp://\", \"http://\")\n                .replace(\"webrtc://\", \"http://\")\n                .replace(\"rtc://\", \"http://\");\n\n            var vhost = a.hostname;\n            var app = a.pathname.substring(1, a.pathname.lastIndexOf(\"/\"));\n            var stream = a.pathname.slice(a.pathname.lastIndexOf(\"/\") + 1);\n\n            // parse the vhost in the params of app, that srs supports.\n            app = app.replace(\"...vhost...\", \"?vhost=\");\n            if (app.indexOf(\"?\") >= 0) {\n                var params = app.slice(app.indexOf(\"?\"));\n                app = app.slice(0, app.indexOf(\"?\"));\n\n                if (params.indexOf(\"vhost=\") > 0) {\n                    vhost = params.slice(params.indexOf(\"vhost=\") + \"vhost=\".length);\n                    if (vhost.indexOf(\"&\") > 0) {\n                        vhost = vhost.slice(0, vhost.indexOf(\"&\"));\n                    }\n                }\n            }\n\n            // when vhost equals to server, and server is ip,\n            // the vhost is __defaultVhost__\n            if (a.hostname === vhost) {\n                var re = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/;\n                if (re.test(a.hostname)) {\n                    vhost = \"__defaultVhost__\";\n                }\n            }\n\n            // parse the schema\n            var schema = \"rtmp\";\n            if (url.indexOf(\"://\") > 0) {\n                schema = url.slice(0, url.indexOf(\"://\"));\n            }\n\n            var port = a.port;\n            if (!port) {\n                // Finger out by webrtc url, if contains http or https port, to overwrite default 1985.\n                if (schema === 'webrtc' && url.indexOf(`webrtc://${a.host}:`) === 0) {\n                    port = (url.indexOf(`webrtc://${a.host}:80`) === 0) ? 80 : 443;\n                }\n\n                // Guess by schema.\n                if (schema === 'http') {\n                    port = 80;\n                } else if (schema === 'https') {\n                    port = 443;\n                } else if (schema === 'rtmp') {\n                    port = 1935;\n                }\n            }\n\n            var ret = {\n                url: url,\n                schema: schema,\n                server: a.hostname, port: port,\n                vhost: vhost, app: app, stream: stream\n            };\n            self.__internal.fill_query(a.search, ret);\n\n            // For webrtc API, we use 443 if page is https, or schema specified it.\n            if (!ret.port) {\n                if (schema === 'webrtc' || schema === 'rtc') {\n                    if (ret.user_query.schema === 'https') {\n                        ret.port = 443;\n                    } else if (window.location.href.indexOf('https://') === 0) {\n                        ret.port = 443;\n                    } else {\n                        // For WebRTC, SRS use 1985 as default API port.\n                        ret.port = 1985;\n                    }\n                }\n            }\n\n            return ret;\n        },\n        fill_query: function (query_string, obj) {\n            // pure user query object.\n            obj.user_query = {};\n\n            if (query_string.length === 0) {\n                return;\n            }\n\n            // split again for angularjs.\n            if (query_string.indexOf(\"?\") >= 0) {\n                query_string = query_string.split(\"?\")[1];\n            }\n\n            var queries = query_string.split(\"&\");\n            for (var i = 0; i < queries.length; i++) {\n                var elem = queries[i];\n\n                var query = elem.split(\"=\");\n                obj[query[0]] = query[1];\n                obj.user_query[query[0]] = query[1];\n            }\n\n            // alias domain for vhost.\n            if (obj.domain) {\n                obj.vhost = obj.domain;\n            }\n        }\n    };\n\n    self.pc = new RTCPeerConnection(null);\n\n    // Create a stream to add track to the stream, @see https://webrtc.org/getting-started/remote-streams\n    self.stream = new MediaStream();\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/ontrack\n    self.pc.ontrack = function(event) {\n        if (self.ontrack) {\n            self.ontrack(event);\n        }\n    };\n\n    return self;\n}\n\n// Depends on adapter-7.4.0.min.js from https://github.com/webrtc/adapter\n// Async-awat-prmise based SRS RTC Publisher by WHIP.\nfunction SrsRtcWhipWhepAsync() {\n    var self = {};\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    self.constraints = {\n        audio: true,\n        video: {\n            width: {ideal: 320, max: 576}\n        }\n    };\n\n    // See https://datatracker.ietf.org/doc/draft-ietf-wish-whip/\n    // @url The WebRTC url to publish with, for example:\n    //      http://localhost:1985/rtc/v1/whip/?app=live&stream=livestream\n    self.publish = async function (url) {\n        if (url.indexOf('/whip/') === -1) throw new Error(`invalid WHIP url ${url}`);\n\n        self.pc.addTransceiver(\"audio\", {direction: \"sendonly\"});\n        self.pc.addTransceiver(\"video\", {direction: \"sendonly\"});\n\n        if (!navigator.mediaDevices && window.location.protocol === 'http:' && window.location.hostname !== 'localhost') {\n            throw new SrsError('HttpsRequiredError', `Please use HTTPS or localhost to publish, read https://github.com/ossrs/srs/issues/2762#issuecomment-983147576`);\n        }\n        var stream = await navigator.mediaDevices.getUserMedia(self.constraints);\n\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream#Migrating_to_addTrack\n        stream.getTracks().forEach(function (track) {\n            self.pc.addTrack(track);\n\n            // Notify about local track when stream is ok.\n            self.ontrack && self.ontrack({track: track});\n        });\n\n        var offer = await self.pc.createOffer();\n        await self.pc.setLocalDescription(offer);\n        const answer = await new Promise(function (resolve, reject) {\n            console.log(\"Generated offer: \", offer);\n\n            const xhr = new XMLHttpRequest();\n            xhr.onload = function() {\n                if (xhr.readyState !== xhr.DONE) return;\n                if (xhr.status !== 200 && xhr.status !== 201) return reject(xhr);\n                const data = xhr.responseText;\n                console.log(\"Got answer: \", data);\n                return data.code ? reject(xhr) : resolve(data);\n            }\n            xhr.open('POST', url, true);\n            xhr.setRequestHeader('Content-type', 'application/sdp');\n            xhr.send(offer.sdp);\n        });\n        await self.pc.setRemoteDescription(\n            new RTCSessionDescription({type: 'answer', sdp: answer})\n        );\n\n        return self.__internal.parseId(url, offer.sdp, answer);\n    };\n\n    // See https://datatracker.ietf.org/doc/draft-ietf-wish-whip/\n    // @url The WebRTC url to play with, for example:\n    //      http://localhost:1985/rtc/v1/whep/?app=live&stream=livestream\n    self.play = async function(url) {\n        if (url.indexOf('/whip-play/') === -1 && url.indexOf('/whep/') === -1) throw new Error(`invalid WHEP url ${url}`);\n\n        self.pc.addTransceiver(\"audio\", {direction: \"recvonly\"});\n        self.pc.addTransceiver(\"video\", {direction: \"recvonly\"});\n\n        var offer = await self.pc.createOffer();\n        await self.pc.setLocalDescription(offer);\n        const answer = await new Promise(function(resolve, reject) {\n            console.log(\"Generated offer: \", offer);\n\n            const xhr = new XMLHttpRequest();\n            xhr.onload = function() {\n                if (xhr.readyState !== xhr.DONE) return;\n                if (xhr.status !== 200 && xhr.status !== 201) return reject(xhr);\n                const data = xhr.responseText;\n                console.log(\"Got answer: \", data);\n                return data.code ? reject(xhr) : resolve(data);\n            }\n            xhr.open('POST', url, true);\n            xhr.setRequestHeader('Content-type', 'application/sdp');\n            xhr.send(offer.sdp);\n        });\n        await self.pc.setRemoteDescription(\n            new RTCSessionDescription({type: 'answer', sdp: answer})\n        );\n\n        return self.__internal.parseId(url, offer.sdp, answer);\n    };\n\n    // Close the publisher.\n    self.close = function () {\n        self.pc && self.pc.close();\n        self.pc = null;\n    };\n\n    // The callback when got local stream.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream#Migrating_to_addTrack\n    self.ontrack = function (event) {\n        // Add track to stream of SDK.\n        self.stream.addTrack(event.track);\n    };\n\n    self.pc = new RTCPeerConnection(null);\n\n    // To keep api consistent between player and publisher.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream#Migrating_to_addTrack\n    // @see https://webrtc.org/getting-started/media-devices\n    self.stream = new MediaStream();\n\n    // Internal APIs.\n    self.__internal = {\n        parseId: (url, offer, answer) => {\n            let sessionid = offer.substr(offer.indexOf('a=ice-ufrag:') + 'a=ice-ufrag:'.length);\n            sessionid = sessionid.substr(0, sessionid.indexOf('\\n') - 1) + ':';\n            sessionid += answer.substr(answer.indexOf('a=ice-ufrag:') + 'a=ice-ufrag:'.length);\n            sessionid = sessionid.substr(0, sessionid.indexOf('\\n'));\n\n            const a = document.createElement(\"a\");\n            a.href = url;\n            return {\n                sessionid: sessionid, // Should be ice-ufrag of answer:offer.\n                simulator: a.protocol + '//' + a.host + '/rtc/v1/nack/',\n            };\n        },\n    };\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/ontrack\n    self.pc.ontrack = function(event) {\n        if (self.ontrack) {\n            self.ontrack(event);\n        }\n    };\n\n    return self;\n}\n\n// Format the codec of RTCRtpSender, kind(audio/video) is optional filter.\n// https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs#getting_the_supported_codecs\nfunction SrsRtcFormatSenders(senders, kind) {\n    var codecs = [];\n    senders.forEach(function (sender) {\n        var params = sender.getParameters();\n        params && params.codecs && params.codecs.forEach(function(c) {\n            if (kind && sender.track.kind !== kind) {\n                return;\n            }\n\n            if (c.mimeType.indexOf('/red') > 0 || c.mimeType.indexOf('/rtx') > 0 || c.mimeType.indexOf('/fec') > 0) {\n                return;\n            }\n\n            var s = '';\n\n            s += c.mimeType.replace('audio/', '').replace('video/', '');\n            s += ', ' + c.clockRate + 'HZ';\n            if (sender.track.kind === \"audio\") {\n                s += ', channels: ' + c.channels;\n            }\n            s += ', pt: ' + c.payloadType;\n\n            codecs.push(s);\n        });\n    });\n    return codecs.join(\", \");\n}\n\nexport {\n    SrsRtcPublisherAsync,\n    SrsRtcPlayerAsync,\n    SrsRtcWhipWhepAsync,\n    SrsRtcFormatSenders,\n    SrsError,\n}","import React, { useEffect, useRef } from 'react'\nimport './index.css'\nimport { SrsRtcWhipWhepAsync } from './srs.sdk'\n\nexport interface SrsWhepPlayerProps {\n  url: string\n  options?: React.VideoHTMLAttributes<HTMLVideoElement>\n}\n\nconst getIdFromUrl = (url: string) => {\n  const searchParams = new URLSearchParams(new URL(url).search)\n  const streamValue = searchParams.get('stream')\n  return streamValue || ''\n}\n\nenum Status {\n  Loading = 'loading',\n  Playing = 'playing',\n}\n\nexport const SrsPlayer: React.FC<SrsWhepPlayerProps> = ({ url, options }) => {\n  const videoOptions = {\n    ...{\n      autoPlay: true,\n      playsInline: true,\n      muted: true,\n    },\n    ...options,\n  }\n  const videoRef = useRef<HTMLVideoElement>(null)\n  const srsSdkRef = useRef<SrsRtcWhipWhepAsync | null>(null)\n  const id = getIdFromUrl(url)\n  const [status, setStatus] = React.useState(Status.Loading)\n\n  const startPlay = async () => {\n    srsSdkRef.current = new SrsRtcWhipWhepAsync()\n    try {\n      const parseIdResult = await srsSdkRef.current.play(url)\n      console.log(`SrsWhepPlayer play success on ${id}`, parseIdResult)\n      setStatus(Status.Playing)\n\n      if (videoRef.current) {\n        videoRef.current.srcObject = srsSdkRef.current.stream\n      }\n    } catch (e) {\n      console.error(`SrsWhepPlayer error happens on ${id}`, e)\n      setStatus(Status.Loading)\n    }\n  }\n\n  const cleanup = () => {\n    if (srsSdkRef.current) {\n      srsSdkRef.current.close()\n    }\n    if (videoRef.current) {\n      videoRef.current.srcObject = null\n    }\n  }\n\n  const refresh = () => {\n    cleanup()\n    startPlay()\n  }\n\n  useEffect(() => {\n    startPlay()\n    return () => {\n      cleanup()\n    }\n  }, [url, status])\n\n  return (\n    <div className='video-container'>\n      {status === Status.Loading && (\n        <div className='player-mask'>\n          <span>Loading...</span>\n          <button className='refresh-button-always' onClick={refresh}></button>\n        </div>\n      )}\n      <>\n        <video ref={videoRef} {...videoOptions}></video>\n        <button className='refresh-button' onClick={refresh}></button>\n      </>\n    </div>\n  )\n}\n"],"names":[],"mappings":"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"}